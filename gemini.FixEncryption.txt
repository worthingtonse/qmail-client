# Revised Plan for Implementing "Fix Encryption" in Qmail-Client

This document outlines the significantly revised and detailed plan to implement the "Fix Encryption" step of the healing process, incorporating critical insights from `K. Healing Services for Keys.md` and other documentation. The process is more complex than initially understood, involving "helper" RAIDA and double encryption.

## 1. Goal

The primary goal is to robustly implement the "Fix Encryption" functionality in `src/heal_encryption.py`, enabling the establishment of shared secrets with RAIDA servers where they are currently missing, using the detailed "Healing Services for Keys" protocol.

## 2. Key Insights from `K. Healing Services for Keys.md`

-   **Dedicated "Healing Services For Keys" (Command Group 4, Commands 44 & 45):** This document describes a distinct protocol for fixing encryption keys, separate from the general Healing services (Command Group 2) for coins. This is a critical distinction that will require careful handling of command groups. *Note: There is a contradiction between `K. Healing Services for Keys.md` (Command Group 4) and `heal-system.txt`/`heal_protocol.py` (Command Group 2) for commands 44 and 45. For now, we will proceed assuming `CMD_GROUP_HEALING = 2` as per existing Python code and `heal-system.txt`, but this may require user clarification or adjustment if server implementation dictates Command Group 4.*
-   **Helper RAIDA Involvement:** Fixing encryption on a `broken_raida` requires two "helper" RAIDA that are currently `working_raida` (have a shared secret with the client) and also have a shared secret with the `broken_raida`.
-   **Key (AN) Splitting:** The AN of the coin being fixed is split into two 8-byte parts.
-   **Double Encryption Process (Get Encryption Ticket):**
    1.  Client encrypts `key_part_1` using `Helper RAIDA 1`'s key and sends it to `Helper RAIDA 1` via the "Get Encryption Ticket" (CMD 44) service. This request is encrypted using the client's shared secret with `Helper RAIDA 1`.
    2.  `Helper RAIDA 1` decrypts `key_part_1` and then *re-encrypts* it using a common secret it shares with the `Broken RAIDA`.
    3.  `Helper RAIDA 1` returns the re-encrypted `key_part_1` to the client.
    4.  A similar process occurs with `Helper RAIDA 2` and `key_part_2`.
-   **Unencrypted `Fix Encryption` Request:** The client sends an *unencrypted* request to the `Broken RAIDA` using the "Fix Encryption" (CMD 45) service. This request includes the `fracked_coin`'s details and the two re-encrypted key parts received from the helper RAIDA.
-   **Broken RAIDA's Role:** The `Broken RAIDA` decrypts the re-encrypted key parts (using its shared secrets with the helper RAIDA), reassembles the original AN, and updates its internal record for the specified `fracked_coin`.

## 3. Revised Implementation Plan

### Step 3.1: Enhance `EncryptionHealth` Class

The `EncryptionHealth` class in `src/heal_encryption.py` will be enhanced to manage RAIDA states more comprehensively.

-   **Attributes to Add/Update:**
    -   `is_persistently_broken: List[bool]`: Tracks RAIDA that have consistently failed to fix.
    -   `failure_count: List[int]`: Counts consecutive failed fix attempts per RAIDA.
    -   `last_attempt_time: List[float]`: Records the last attempt time for cooldown management.
    -   `cooldown_seconds: int`: Configurable time to wait before retrying persistently broken RAIDA.
-   **Methods to Add/Update:**
    -   `mark_failed(raida_id, max_failures=3)`: Increments failure count, marks as persistently broken if threshold reached.
    -   `can_retry(raida_id)`: Checks if a RAIDA can be retried based on cooldown and persistent broken status.

### Step 3.2: Refactor `fix_encryption` Orchestrator (Major Changes)

The `fix_encryption` function in `src/heal_encryption.py` will be completely overhauled to orchestrate the complex "Healing Services for Keys" protocol.

-   **Initialization & RAIDA Categorization:**
    1.  Retrieve `broken_raida_ids` from `health.get_broken_raida()`, respecting the cooldown and `is_persistently_broken` status.
    2.  Retrieve `working_raida_ids` from `health.get_working_raida()`.
    3.  If no `broken_raida_ids` or insufficient `working_raida_ids` (less than 2 for helpers + 1 for fix target), log and return.

-   **Coin Selection & Key Splitting:**
    1.  Load all coins from `BANK` and `FRACKED` folders.
    2.  For each `broken_raida_id` in `broken_raida_ids`:
        a.  Find a suitable `fracked_coin`: A coin that is fracked on `broken_raida_id` (i.e., `pown[broken_raida_id] == 'f'`) but *not* fracked on at least two `working_raida_ids` (which will become helper RAIDA). This `fracked_coin` will provide the AN to be fixed.
        b.  If no such coin is found, log a warning and mark `broken_raida_id` as potentially persistently broken.
        c.  Split the `fracked_coin.ans[broken_raida_id]` into two 8-byte `key_part_1` and `key_part_2`.

-   **Helper RAIDA Selection:**
    1.  For each `broken_raida_id`, select two distinct `helper_raida_ids` from the `working_raida_ids`. Prioritize `working_raida_ids` that are not currently involved in fixing another `broken_raida_id` in the current batch. Ensure the selected helper RAIDA are active and responsive.

-   **Parallel `Get Encryption Ticket` (to Helper RAIDA):**
    1.  Utilize `concurrent.futures.ThreadPoolExecutor` to perform parallel calls to the *modified* `get_encryption_ticket` function (see Step 3.3).
    2.  For each `broken_raida_id` and its `fracked_coin`:
        *   Call `get_encryption_ticket(helper_raida_1, broken_raida_id, fracked_coin_details, key_part_1)`.
        *   Call `get_encryption_ticket(helper_raida_2, broken_raida_id, fracked_coin_details, key_part_2)`.
    3.  Collect the two 16-byte `re_encrypted_key_parts` for each `broken_raida_id`. Handle failures (e.g., helper RAIDA unresponsive, ticket not obtained).

-   **Parallel `Fix Encryption` (to Broken RAIDA):**
    1.  Utilize `concurrent.futures.ThreadPoolExecutor` to perform parallel calls to the *modified* `fix_encryption_on_raida` function (see Step 3.4).
    2.  For each `broken_raida_id` and its `fracked_coin`:
        *   Call `fix_encryption_on_raida(broken_raida_id, fracked_coin_details, re_encrypted_key_part_1, re_encrypted_key_part_2)`.
    3.  Collect results. On success, call `health.mark_fixed(broken_raida_id)`. On failure, call `health.mark_failed(broken_raida_id)`.

-   **Logging and Error Handling:** Implement robust logging at each stage, detailing which RAIDA are being targeted, which helpers are used, and the success/failure of each sub-operation.

### Step 3.3: Redefine `get_encryption_ticket` Function (Significant Changes)

The existing `get_encryption_ticket` in `src/heal_encryption.py` will be heavily modified to implement the client-to-helper RAIDA interaction for double encryption.

-   **Inputs:** `helper_raida_id: int`, `target_broken_raida_id: int`, `fracked_coin: CloudCoinBin`, `key_part: bytes` (8 bytes).
-   **Output:** `Tuple[HealErrorCode, bytes]` (where `bytes` is the 16-byte `re_encrypted_key_part`).
-   **Logic:**
    1.  **Build Encrypted Request (Client -> Helper):**
        *   Construct the request header (using `CMD_GROUP_HEALING` as 2 or 4, depending on clarification, `CMD_GET_ENCRYPTION_TICKET` as 44). This request must be encrypted using the client's shared secret with `helper_raida_id`.
        *   The request body will include the challenge, `fracked_coin.denomination`, `fracked_coin.serial_number`, the 8-byte `key_part`, and `target_broken_raida_id`.
    2.  **Send Request:** Use `heal_network.send_request` to send the request to `helper_raida_id`.
    3.  **Parse Response:**
        *   Decrypt the response from `helper_raida_id`.
        *   Extract the 16-byte `re_encrypted_key_part` from the response body.
    4.  Return the `re_encrypted_key_part`.

### Step 3.4: Redefine `fix_encryption_on_raida` Function (Significant Changes)

The existing `fix_encryption_on_raida` in `src/heal_encryption.py` will be heavily modified to implement the client-to-broken RAIDA interaction for final key assembly.

-   **Inputs:** `broken_raida_id: int`, `fracked_coin: CloudCoinBin`, `re_encrypted_key_part_1: bytes` (16 bytes), `re_encrypted_key_part_2: bytes` (16 bytes).
-   **Output:** `HealErrorCode` (and possibly parsed hash/status from the RAIDA response).
-   **Logic:**
    1.  **Build Unencrypted Request (Client -> Broken):**
        *   Construct the request header (`CMD_GROUP_HEALING` as 2 or 4, `CMD_FIX_ENCRYPTION` as 45). Crucially, this request *must be unencrypted*.
        *   The request body will include the challenge, `fracked_coin.denomination`, `fracked_coin.serial_number`, and the two 16-byte `re_encrypted_key_parts`.
    2.  **Send Request:** Use `heal_network.send_request` to send the request to `broken_raida_id`.
    3.  **Parse Response:** Parse the unencrypted response from `broken_raida_id` to determine success/failure and extract any relevant status (e.g., hash of the reassembled key, `Key accepted status`).

### Step 3.5: Implement Helper Functions for Key Splitting/Combining

-   Add functions in `heal_encryption.py` (or `heal_protocol.py`) to reliably split a 16-byte AN into two 8-byte parts and combine two 8-byte parts back into a 16-byte AN.

### Step 3.6: Update `heal_protocol.py` (If necessary)

-   Review `heal_protocol.py` to ensure `CMD_GET_ENCRYPTION_TICKET` and `CMD_FIX_ENCRYPTION` are correctly defined for Command Group 2 (Healing) or 4 (Key Healing) as per final decision. Update constants if needed.

### Step 3.7: Create Comprehensive Unit Tests

The test file `tests/test_heal_encryption.py` will be developed or significantly updated.

-   **`EncryptionHealth` Tests:** Test the new state management (`is_persistently_broken`, `failure_count`, cooldown logic).
-   **Key Splitting/Combining Tests:** Verify the correctness of AN splitting and reassembly.
-   **`get_encryption_ticket` Tests:** Mock `heal_network.send_request` to simulate helper RAIDA responses (including the double-encryption behavior).
-   **`fix_encryption_on_raida` Tests:** Mock `heal_network.send_request` to simulate broken RAIDA responses to the unencrypted fix request.
-   **`fix_encryption` Orchestrator Integration Test:** Create a full integration test with mocks for helper and broken RAIDA, verifying the entire flow from identifying broken RAIDA to updating `EncryptionHealth` status. This will be the most complex test.

This revised plan addresses the complexities introduced by the "Healing Services for Keys" protocol, aiming for a robust and correct implementation.
