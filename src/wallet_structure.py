"""
wallet_structure.py - Wallet Folder Structure Management

This module creates and manages the file structure for QMail wallets.
The structure includes folders for storing CloudCoins, transaction records,
and various operational states.

Author: Claude Opus 4.5
Date: 2025-12-21
Updated: 2025-12-22 (Feedback fixes: base path, creation reporting, logging)

Usage:
    from src.wallet_structure import initialize_wallet_structure

    # Initialize on program startup
    initialize_wallet_structure()

    # With logger integration
    initialize_wallet_structure(logger=my_logger)
"""

import os
import sys
from typing import List, Tuple, Optional, Any, Callable


# ============================================================================
# CONSTANTS - Wallet Folder Structure
# ============================================================================

# Base paths relative to executable
DATA_FOLDER = "Data"
WALLETS_FOLDER = "Wallets"

# Default wallet names
DEFAULT_WALLET = "Default"
MAILBOX_WALLET = "Mailbox"

# Subfolders required in each wallet (from folder_structure.png)
WALLET_SUBFOLDERS = [
    "Gallery",              # Gallery storage
    "Personal",             # Personal items
    "Attachments",          # Email attachments
    "Bank",                 # Authenticated CloudCoins (good coins)
    "Bucket",               # Temporary bucket storage
    "Contacts",             # Contact information
    "Duplicates",           # Duplicate coins
    "Downloads",            # Downloaded items
    "Emailed",              # Successfully emailed coins
    "EmailFailed",          # Failed email attempts
    "Decryption_Failed",    # Coins that failed decryption
    "Erased",               # Erased/deleted coins
    "Export",               # Exported coins
    "Fracked",              # Coins in fracked state (need fix)
    "Frack_Failed",         # Coins that failed fracking
    "Fraud",                # Fraudulent coins detected
    "ID",                   # Identity-related files
    "Import",               # Coins to be imported
    "Limbo",                # Coins in uncertain state
    "Locked",               # Locked coins
    "Logs",                 # Wallet-specific logs
    "NeedsDecryption",      # Coins requiring decryption
    "PayForward",           # Coins for paying forward
    "PayReceived",          # Received payments
    "Receipts",             # Transaction receipts
    "RequestResponses",     # Server request responses
    "Sent",                 # Successfully sent coins
    "Suspect",              # Suspicious coins
    "TentativeWithdraw",    # Tentative withdrawals
    "TrustedTransfer",      # Trusted transfer operations
    "Prewithdraw",          # Pre-withdrawal staging
    "Withdrawn",            # Withdrawn coins
]

# Files to create in each wallet
WALLET_FILES = {
    "config.toml": """# Wallet Configuration
# Generated by QMail Client

[wallet]
name = "{wallet_name}"
created = "{created_date}"
version = "1.0.0"

[settings]
auto_fix = true
backup_enabled = true
""",
    "transactions.csv": "timestamp,type,amount,from,to,status,notes\n"
}


# ============================================================================
# LOGGING HELPER
# ============================================================================

def _log_error(logger: Any, message: str, log_func: Optional[Callable] = None) -> None:
    """
    Log an error message using the provided logger or print to stdout.

    Args:
        logger: Logger handle (can be None)
        message: Error message to log
        log_func: Optional logging function (e.g., log_error from logger module)
    """
    if logger is not None and log_func is not None:
        try:
            log_func(logger, "WalletStructure", message)
        except Exception:
            # Fall back to print if logging fails
            print(f"[ERROR] {message}")
    else:
        print(f"[ERROR] {message}")


def _log_info(logger: Any, message: str, log_func: Optional[Callable] = None) -> None:
    """
    Log an info message using the provided logger or print to stdout.

    Args:
        logger: Logger handle (can be None)
        message: Info message to log
        log_func: Optional logging function (e.g., log_info from logger module)
    """
    if logger is not None and log_func is not None:
        try:
            log_func(logger, "WalletStructure", message)
        except Exception:
            # Fall back to print if logging fails
            print(f"[INFO] {message}")
    else:
        print(f"[INFO] {message}")


# ============================================================================
# FOLDER CREATION FUNCTIONS
# ============================================================================

def _create_folder_if_not_exists(path: str, logger: Any = None,
                                  log_error_func: Optional[Callable] = None) -> Tuple[bool, bool]:
    """
    Create a folder if it doesn't exist.
    Does NOT modify the folder if it already exists (preserves modification time).

    Args:
        path: Full path to the folder to create
        logger: Optional logger handle for error reporting
        log_error_func: Optional log_error function

    Returns:
        Tuple of (success: bool, was_created: bool)
        - success: True if folder exists or was created, False on error
        - was_created: True if folder was newly created, False if already existed
    """
    # Check existence BEFORE attempting creation (fixes reporting bug)
    already_exists = os.path.exists(path)

    if already_exists:
        return True, False  # Already exists, not created

    try:
        os.makedirs(path, exist_ok=True)
        return True, True  # Created successfully
    except OSError as e:
        _log_error(logger, f"Failed to create folder '{path}': {e}", log_error_func)
        return False, False


def _create_file_if_not_exists(path: str, content: str, logger: Any = None,
                                log_error_func: Optional[Callable] = None) -> Tuple[bool, bool]:
    """
    Create a file with content if it doesn't exist.
    Does NOT modify the file if it already exists (preserves modification time).

    Args:
        path: Full path to the file to create
        content: Content to write to the file
        logger: Optional logger handle for error reporting
        log_error_func: Optional log_error function

    Returns:
        Tuple of (success: bool, was_created: bool)
        - success: True if file exists or was created, False on error
        - was_created: True if file was newly created, False if already existed
    """
    # Check existence BEFORE attempting creation (fixes reporting bug)
    already_exists = os.path.exists(path)

    if already_exists:
        return True, False  # Already exists, not created

    try:
        # Ensure parent directory exists
        parent_dir = os.path.dirname(path)
        if parent_dir and not os.path.exists(parent_dir):
            os.makedirs(parent_dir, exist_ok=True)

        with open(path, 'w', encoding='utf-8') as f:
            f.write(content)
        return True, True  # Created successfully
    except IOError as e:
        _log_error(logger, f"Failed to create file '{path}': {e}", log_error_func)
        return False, False


def _get_base_path() -> str:
    """
    Get the base path for the Data folder.
    Uses the directory of the executable or main script, NOT the current working directory.

    Priority order:
    1. Directory of sys.argv[0] (the script being run)
    2. Directory of sys.executable (for frozen/packaged apps)
    3. Directory of this module file (fallback)

    Returns:
        Absolute path to the base folder location
    """
    # Priority 1: Use the directory of the main script (sys.argv[0])
    # This handles: python src/app.py, python main.py, etc.
    if sys.argv and sys.argv[0]:
        main_script = os.path.abspath(sys.argv[0])
        main_dir = os.path.dirname(main_script)

        # If running from src/, go up one level to project root
        if os.path.basename(main_dir) == "src":
            main_dir = os.path.dirname(main_dir)

        # Verify it's a valid directory
        if os.path.isdir(main_dir):
            return main_dir

    # Priority 2: For frozen/packaged executables (PyInstaller, etc.)
    # sys.executable points to the actual executable
    if getattr(sys, 'frozen', False):
        exe_dir = os.path.dirname(os.path.abspath(sys.executable))
        if os.path.isdir(exe_dir):
            return exe_dir

    # Priority 3: Fallback to this module's location
    # Go up from src/wallet_structure.py to project root
    current_file = os.path.abspath(__file__)
    src_dir = os.path.dirname(current_file)
    project_root = os.path.dirname(src_dir)

    if os.path.isdir(project_root):
        return project_root

    # Last resort: current working directory (with warning)
    # This should rarely happen
    return os.getcwd()


# ============================================================================
# WALLET INITIALIZATION
# ============================================================================

def create_wallet_folders(wallet_path: str, wallet_name: str,
                          logger: Any = None,
                          log_error_func: Optional[Callable] = None) -> Tuple[bool, List[str]]:
    """
    Create all required subfolders for a wallet.

    Args:
        wallet_path: Full path to the wallet folder
        wallet_name: Name of the wallet (for config file)
        logger: Optional logger handle for error reporting
        log_error_func: Optional log_error function

    Returns:
        Tuple of (success: bool, created_items: list of created paths)
    """
    created_items = []
    success = True

    # Create the wallet root folder (track if created)
    ok, was_created = _create_folder_if_not_exists(wallet_path, logger, log_error_func)
    if not ok:
        return False, created_items
    if was_created:
        created_items.append(wallet_path)

    # Create all subfolders
    for subfolder in WALLET_SUBFOLDERS:
        subfolder_path = os.path.join(wallet_path, subfolder)
        ok, was_created = _create_folder_if_not_exists(subfolder_path, logger, log_error_func)
        if not ok:
            success = False
        elif was_created:
            created_items.append(subfolder_path)

    # Create wallet files
    from datetime import datetime
    created_date = datetime.now().strftime("%Y-%m-%d")

    for filename, template in WALLET_FILES.items():
        file_path = os.path.join(wallet_path, filename)
        content = template.format(
            wallet_name=wallet_name,
            created_date=created_date
        )
        ok, was_created = _create_file_if_not_exists(file_path, content, logger, log_error_func)
        if not ok:
            success = False
        elif was_created:
            created_items.append(file_path)

    return success, created_items


def initialize_wallet_structure(base_path: Optional[str] = None,
                                 logger: Any = None) -> Tuple[bool, dict]:
    """
    Initialize the complete wallet folder structure.

    Creates:
        Data/
        Data/Wallets/
        Data/Wallets/Default/  (with all subfolders)
        Data/Wallets/Mailbox/  (with all subfolders)

    This function is idempotent - it will not modify existing folders or files,
    preserving their modification timestamps.

    Args:
        base_path: Optional base path. If None, auto-detects from executable location.
        logger: Optional logger handle for error/info reporting. If provided,
                errors will be logged through the application's logging system.

    Returns:
        Tuple of (success: bool, result: dict with details)

    Example:
        success, result = initialize_wallet_structure()
        if success:
            print(f"Created {len(result['created'])} items")

        # With logger
        success, result = initialize_wallet_structure(logger=app_logger)
    """
    # Try to import logger functions if logger is provided
    log_error_func = None
    log_info_func = None
    if logger is not None:
        try:
            from src.logger import log_error, log_info
            log_error_func = log_error
            log_info_func = log_info
        except ImportError:
            pass  # Logger module not available, will use print

    result = {
        "success": True,
        "base_path": "",
        "created": [],
        "errors": []
    }

    # Determine base path
    if base_path is None:
        base_path = _get_base_path()

    result["base_path"] = base_path

    # Create Data folder (track if created)
    data_path = os.path.join(base_path, DATA_FOLDER)
    ok, was_created = _create_folder_if_not_exists(data_path, logger, log_error_func)
    if not ok:
        result["success"] = False
        result["errors"].append(f"Failed to create Data folder: {data_path}")
        return False, result
    if was_created:
        result["created"].append(data_path)

    # Create Wallets folder (track if created)
    wallets_path = os.path.join(data_path, WALLETS_FOLDER)
    ok, was_created = _create_folder_if_not_exists(wallets_path, logger, log_error_func)
    if not ok:
        result["success"] = False
        result["errors"].append(f"Failed to create Wallets folder: {wallets_path}")
        return False, result
    if was_created:
        result["created"].append(wallets_path)

    # Create Default wallet
    default_path = os.path.join(wallets_path, DEFAULT_WALLET)
    success, created = create_wallet_folders(default_path, DEFAULT_WALLET, logger, log_error_func)
    result["created"].extend(created)
    if not success:
        result["success"] = False
        result["errors"].append("Failed to create Default wallet structure")

    # Create Mailbox wallet
    mailbox_path = os.path.join(wallets_path, MAILBOX_WALLET)
    success, created = create_wallet_folders(mailbox_path, MAILBOX_WALLET, logger, log_error_func)
    result["created"].extend(created)
    if not success:
        result["success"] = False
        result["errors"].append("Failed to create Mailbox wallet structure")

    return result["success"], result


def get_wallet_path(wallet_name: str = DEFAULT_WALLET,
                    base_path: Optional[str] = None) -> str:
    """
    Get the full path to a wallet folder.

    Args:
        wallet_name: Name of the wallet (Default, Mailbox, or custom)
        base_path: Optional base path. If None, auto-detects.

    Returns:
        Full path to the wallet folder
    """
    if base_path is None:
        base_path = _get_base_path()

    return os.path.join(base_path, DATA_FOLDER, WALLETS_FOLDER, wallet_name)


def get_wallet_subfolder(wallet_name: str, subfolder: str,
                         base_path: Optional[str] = None) -> str:
    """
    Get the full path to a wallet subfolder.

    Args:
        wallet_name: Name of the wallet
        subfolder: Name of the subfolder (e.g., "Bank", "Fracked")
        base_path: Optional base path. If None, auto-detects.

    Returns:
        Full path to the subfolder

    Example:
        bank_path = get_wallet_subfolder("Default", "Bank")
    """
    wallet_path = get_wallet_path(wallet_name, base_path)
    return os.path.join(wallet_path, subfolder)


def verify_wallet_structure(wallet_name: str = DEFAULT_WALLET,
                           base_path: Optional[str] = None) -> Tuple[bool, List[str]]:
    """
    Verify that a wallet has all required folders and files.

    Args:
        wallet_name: Name of the wallet to verify
        base_path: Optional base path. If None, auto-detects.

    Returns:
        Tuple of (is_complete: bool, missing_items: list of missing paths)
    """
    wallet_path = get_wallet_path(wallet_name, base_path)
    missing = []

    # Check wallet root exists
    if not os.path.exists(wallet_path):
        missing.append(wallet_path)
        return False, missing

    # Check subfolders
    for subfolder in WALLET_SUBFOLDERS:
        subfolder_path = os.path.join(wallet_path, subfolder)
        if not os.path.exists(subfolder_path):
            missing.append(subfolder_path)

    # Check files
    for filename in WALLET_FILES.keys():
        file_path = os.path.join(wallet_path, filename)
        if not os.path.exists(file_path):
            missing.append(file_path)

    return len(missing) == 0, missing


# ============================================================================
# MAIN (for testing)
# ============================================================================

if __name__ == "__main__":
    print("=" * 60)
    print("Wallet Structure Initialization Test")
    print("=" * 60)

    # Show base path detection info
    print(f"\nBase Path Detection:")
    print(f"  sys.argv[0]: {sys.argv[0] if sys.argv else 'N/A'}")
    print(f"  sys.executable: {sys.executable}")
    print(f"  Frozen: {getattr(sys, 'frozen', False)}")
    print(f"  Detected base: {_get_base_path()}")

    # Initialize structure
    success, result = initialize_wallet_structure()

    print(f"\nBase Path: {result['base_path']}")
    print(f"Success: {success}")

    if result['created']:
        print(f"\nCreated {len(result['created'])} items:")
        for item in result['created']:
            print(f"  + {item}")
    else:
        print("\nNo new items created (structure already exists)")

    if result['errors']:
        print(f"\nErrors:")
        for error in result['errors']:
            print(f"  ! {error}")

    # Verify structure
    print("\n" + "=" * 60)
    print("Verification")
    print("=" * 60)

    for wallet in [DEFAULT_WALLET, MAILBOX_WALLET]:
        is_complete, missing = verify_wallet_structure(wallet)
        print(f"\n{wallet} wallet: {'Complete' if is_complete else 'Incomplete'}")
        if missing:
            print(f"  Missing items:")
            for item in missing:
                print(f"    - {item}")
